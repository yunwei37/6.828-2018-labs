# MIT 6.828 操作系统工程 lab3B:页面错误，断点异常和系统调用

>这篇是我自己探索实现 MIT 6.828 lab3B 的笔记记录，会包含一部分代码注释和要求的翻译记录，以及踩过的坑/个人的解决方案

这里是我实现的完整代码仓库，也包含其他笔记等等：[https://github.com/yunwei37/6.828-2018-labs](https://github.com/yunwei37/6.828-2018-labs)


## B部分：页面错误，断点异常和系统调用

现在，您的内核具有基本的异常处理功能，您将对其进行优化，以提供依赖于异常处理的重要操作系统原语。

### 处理页面错误

> 页面错误异常，中断向量14（T_PGFLT），是一个特别重要的异常，我们将在本实验以及下一个实验中大量使用它。当处理器发生页面错误时，它将导致错误的线性（即虚拟）地址存储在特殊的处理器控制寄存器CR2中。在trap.c中， 我们提供了特殊功能的开头 page_fault_handler()，以处理页面错误异常。

练习5.进行 修改trap_dispatch() 以将页面错误异常调度到page_fault_handler()。

这很简单，在 trap_dispatch 里面加上：

```c
	if (tf->tf_trapno == T_PGFLT){
		page_fault_handler(tf);
		return;
	}
```

### 断点异常

> 断点异常，中断向量3（T_BRKPT），通常用于允许调试器通过用特殊的1字节int3软件中断指令临时替换相关的程序指令，从而在程序代码中插入断点。在JOS中，我们将通过将其转变成原始的伪系统调用（任何用户环境都可以用来调用JOS内核监视器）来稍微滥用此异常。

练习6.进行 修改trap_dispatch() 以使断点异常调用内核监视器。现在，您应该能够make grade 成功完成断点测试:

这也很简单，在 trap_dispatch 里面加上：

```c
	if (tf->tf_trapno == T_BRKPT){
		monitor(tf);
		return;
	}
```

问题：

1. 断点测试用例将生成断点异常或常规保护错误，具体取决于您如何初始化IDT中的断点条目（即，对SETGATEfrom 的调用 trap_init）。为什么？为了使断点异常按上述规定工作，您需要如何对其进行设置？什么不正确的设置将导致它触发常规保护故障？

	这取决于设置的 `Descriptor Privilege Level`, 我们之前使用的是 3， 这样它就可以从用户态被对应指令触发，如果是 0 的话就会导致保护异常：`SETGATE(idt[3], 1, GD_KT, handler3, 3);`

2. 您认为这些机制的目的是什么，特别是考虑到 user/softint 测试程序的作用？

	还是内核和用户态权限保护隔离设计的一部分。

### 系统调用

> 用户进程要求内核通过调用系统调用来为它们做事。当用户进程调用系统调用时，处理器进入内核模式，处理器和内核协作以保存用户进程的状态，内核执行适当的代码以执行系统调用，然后恢复用户进程。用户进程如何引起内核注意以及如何指定要执行的调用的确切细节因系统而异。

```c
```

```c
```


```c
```

### 用户模式启动

> 用户程序开始在 lib/entry.S的顶部运行 。进行一些设置之后，libmain() 在 lib/libmain.c 中被调用。你应该修改 libMain（）来初始化全局指针 thisenv. 提示：查看inc / env.h并使用 sys_getenvid.

练习8. 将所需的代码添加到用户库，然后启动内核。

```c
```

### 页面错误和内存保护

内存保护是操作系统的一项重要功能，可确保一个程序中的错误不会破坏其他程序或破坏操作系统本身。

```c
```